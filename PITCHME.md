# Web Python

@fa[code fa-3x]

Веб приложения на Python. Flask и другие фреймворки.

> Часть первая

Note:

- Надо сделать тестовый рассказ и определиться, что войдёт в первую лекцию,
а что придётся сдвинуть
- какие интерактивные примеры можно привести, где разместить их в повествовании,
в каком формате подготовить

---

## Содержание

@ul

- Веб приложения
- Фреймворки
- Flask
- Django
- Deployment
- Микросервисы
- Практическое задание

@ulend

Note:

Для начала рассмотрим что из себя представляет веб приложение в целом;
какие бывают архитектурные и концептуальные подходы и т.п.

- Заострить внимание на применении и структуре приложений
- Какие из них мы рассмотрим подробней, на примере фреймворков питона
- Добавить NOTA BENE после каждой темы, с краткими выводами

---

## Web

- Общая идея
- Какие бывают приложения
- Архитектура

---

### Веб приложение это

Приложение, в котором клиент взаимодействует с сервером при помощи браузера.

@ul
- клиентская часть реализует пользовательский интерфейс, формирует запросы к серверу и обрабатывает ответы от него
- серверная часть получает запрос от клиента, выполняет требуемые действия, формирует ответ
@ulend

Note:

- обозначить понятия фронтенд и бэкенд
- немного про то, как это появилось и развивается

---

### Классическая схема

![Legacy Web app](img/1-web-app.png)

Note:

Клиент обращается к приложению, которое генерирует в ответ статический html

---

### Асинхронные виджеты

![Widgets](img/2-web-app.png)

Note:

Отдельные элементы на странице обновляются асинхронно, через особые
взаимодействия с бэкендом

---

### Single Page Application

![SPA](img/3-web-app.png)

Note:

- фронтенд и бэкенд существуют отдельно друг от друга
- потенциально, бэкенд (или фронтенд) можно полностью заменить на другой, без
особых проблем
---

### Общая схема

![Web application at a glance](img/4-web-app.png)

Note:

- может включать в себя очень много чего
- в лекциях будем рассматривать преимущественно само "приложение"
- но также затронем и остальные моменты

---

### Веб приложения. Nota bene

@ul

- Frontend это HTML, CSS, JS - интерфейс для пользователя
- Backend предоставляет "интерфейс" для фронтенда
- На деле граница между ними бывает довольно размытой
- Последние тенденции как сближают, так и разделяют эти два компонента веб приложений

@ulend

Note:

Необходимо подвести к разделению на frontend/backend и рассказать подробней о
грани (или её отсутствии) между ними.

---

### Простейшие функции веб приложения (pending)

- отображение страниц
- авторизация
- отображение данных
- сохранение данных

Note:

- бесконечно много, рассмотрим основные

---


## Инструментарий

@ul

- Встроенные модули питона
- Flask
- Django
- Прочие (Bottle, Pyramids, Tornado)

@ulend

---

### HTTP server

Доступен "из коробки", реализован на основе `socketserver.TCPServer`

> python -m http.server 8000

---?code=src/1-http-server.py&lang=py&color=white&title=Http server example

@[1-2](Импортируем socketserver и HTTP обработчик)
@[3-5](Модули логгирования и работы с файловой системой)
@[7](Назначим свою версию обработчика HTTP запросов)
@[9-11](Переопределяем метод GET)
@[13](Модифицируем стартовую директорию)
@[15-16](Запускаем сервер с нашим HTTP обработчиком)


Note:
- по умолчанию раздаёт текущую директорию или файл index.html
- модифицируем текущую директорию и метод GET

---

## Flask

@ul

- Установка и конфигурация
- Примеры функциональности
- Структура проекта
- Blueprints
- Готовые модули

@ulend

Note:

- почему Flask это микро-фреймворк
- Flask как проект-шутка (немного об истории)
- что включает в себя Flask

---

### Flask. Вступление

@ul

- Имплементирует WSGI приложение
- Встроенный шаблонизатор Jinja2
- Множество готовых расширений
- Минималистичный и протестированный
- Простая конфигурация, API и setup
- Bring Your Own Batteries
- Появился в качестве первоапрельского проекта

@ulend

Note:

- упомянуть про Werkzeug (инструмент) WSGI web application library/utilities
- WSGI рассмотрим дальше

---

### Flask. Рабочее окружение

```bash
pip intall pipenv

pipenv install flask

pipenv shell
```

*Pipenv* - Священный союз Pipfile, Pip, и Virtualenv.

Note:

- для данного приложения задействуем виртуальное окружение
- дальше рассмотрим альтернативные варианты создания development окружения

<!-- ### Flask. Простое приложение -->

---?code=src/flask/1-simple.py&lang=py&color=white&title=Flask. Basics
@[1](Импортируем Flask и его утилиты)
@[3](Создаём приложение)
@[5-7](Назначаем маршрут 'Hello World')
@[9-11](Добавляем редирект с корневого url)
@[13-14](Запускаем приложение)

---

### Flask. Переменные окружения

```bash
set FLASK_APP=1-simple.py
```

Flask, python-dotenv и Pipenv позволяют задать определённые переменные
рабочего или серверного окружения.

```bash
# .env
FLASK_APP=1-simple.py
FLASK_ENV=development
FLASK_RUN_PORT=8000
VERY_SECRET_KEY=qwerty
```

> flask run

---

### Flask. Read-Eval-Print-Loop

> flask shell

```python
>>> app.name
'1-simple'

>>> app.view_functions
{'static': <bound method _PackageBoundObject.send_static_file of <Flask '1-simple'>>,
 'hello': <function hello at 0x000001FF97680598>,
 'home': <function home at 0x000001FF97680730>}

>>> app.view_functions['hello']('Man')
'Hello Man!'
```
@[1-2](Наше приложение)
@[4-7](Маршруты/методы)
@[9-10](Пытаемся вызвать метод hello)

Note:

- что такое bound method vs function
- что это за метод такой, send_static_file

<!-- ### Flask. Шаблон -->

---?code=src/flask/2-template.py&lang=py&color=white&title=Flask. Using templates
@[5](Обозначим данные)
@[9](Выведем данные в шаблон)

Note:

Пару минут на демонстрацию, можно что-нибудь модифицировать в рамках
jinja конструкций

---?code=src/flask/templates/fish.html&lang=html&color=white&title=Flask. Template
@[1,2,12](Это HTML страница)
@[3-5](Назовём её согласно содержимому)
@[6-11](Выведем в цикле всех рыбок)

Note:

- файлы шаблонов надо где-то хранить
- шаблонизаторы и что это такое
- более подробно рассмотрим на примере шаблонизатора Django

<!-- Flask. Запросы -->

---?code=src/flask/3-request.py&lang=py&color=white&title=Flask. Request
@[1-2](Задействуем дополнительные модули Flask)
@[3-4](Для пущего удобства)
@[6-10](Эмулируем некое подобие сервиса для получения данных)
@[14-15](Назначаем маршрут для получения информации о записи)
@[16-18](Обрабатываем GET параметр)
@[19-21](Получаем запись из сервиса)
@[23-26](Форматируем и возвращаем данные в качестве ответа)
@[28-29,30,33](Маршрут для перечисления и добавления записей)
@[30-31](Выводим все имеющиеся записи)
@[35-38](Обрабатываем POST запрос)
@[34,40-41](Проверяем запрос на возможные ошибки)

Note:

- атрибуты request'а: фрагменты url, параметры get, данные POST'а
- Content-Type: может быть multipart/form-data, text/plain, etc
- обратить внимание на возможные ошибки: json.loads, ключ name и прочее

---

### Flask. Пример запроса

> curl -d "name=corydoras&size=medium" -X POST http://localhost:5000/

Различные утилиты для HTTP запросов:

- cURL
- Postman
- Insomnia (бывший Hurl.it)

Note:

- 2 минуты на демонстрацию
- показать сами утилиты или сайты

---

### Flask. Структура проекта

Готовые шаблоны для различных приложений, в том числе и для Python.

> cookiecutter gh:user/repo

Note:

Утилита написана на Python

---

### Flask. Пример структуры проекта

```bash
.
├── .env                    # переменные окружения
├── run.py                  # точка входа в приложение
├── client.js               # точка входа для фронтенда
└── app
    ├── client
    │   ├── build           # артефакты фронтенда
    │   ├── static          # JS, CSS, картинки
    │   └── templates       # шаблоны
    └── server
        ├── config.py       # конфигурация приложения
        ├── main            # главный модуль
        │   └── views.py    # маршруты
        ├── models.py       # модели данных
        └── user            # модуль пользователя
```
@[2-4](Может содержать прочие утилиты и файлы конфигурации)
@[5-15](Само приложение Flask)
@[6-9](Всё что связано с фронтендом)
@[10-15](Бэкенд и прочая логика)
@[12-13](Отдельный Blueprint)

Note:

- Pipenv, .env и переменные окружения
- упомянуть про cli и инструментарий, БД, утилиты
- упомянуть про client pipeline и что он делает
- что такое загадочные "артефакты фронтенда"

---

### Flask. Blueprints

Blueprint - модуль приложения, обособленный согласно определённой логике

```bash
app/
    errors/                 # модуль ошибок
        __init__.py         # инициализация модуля
        handlers.py         # обработка ошибок
    templates/
        errors/             # шаблоны ошибок
            404.html
            500.html
    __init__.py             # регистрируем blueprint
```

<!-- Пример Blueprint'а -->

---?code=src/flask/4-blueprint.py&lang=py&color=white&title=Flask. Errors Blueprint
@[1-6](Инициализация модуля ошибок)
@[10-17](Пример обработчика ошибки 404)
@[20-25](Подключение модуля к основному приложеню)

Note:

- __init__.py как маркер директории, содержащей package
- также может содержать инструкции по инициализации

---

### Flask. Готовые модули

Для расширения функциональности Flask доступно большое количество модулей:

@ul

- **Flask-Login**: сессия и авторизация
- **Flask-Admin**: административный интерфейс
- **Flask-Restful**: создание REST API
- **Flask-SQLAlchemy**: работа с базой данных
- **Flask-Migrate**: создание миграций

@ulend

https://github.com/humiaozuzu/awesome-flask

---

<!-- ### Flask. SQLAlchemy

Кратко рассмотрим некоторые примеры...

--- -->

## Django

@ul

- В чём отличие
- Установка и модули
- Консольная утилита
- Структура приложения
- База данных и миграции
- REST API

@ulend

---

### Django. Вступление

<!-- Фреймворк для перфекционистов с дэдлайнами -->

@ul

- Административный и консольный интерфейсы
- ORM для базы данных и миграции
- Базовый пользователь и аутентификация
- Пользовательские сессии
- Множество middleware для различных целей
- i18n, l10n
- "Это надо делать вот так"

@ulend

Note:

- Чем локализация отличается от интернационализации

---

### Django. Структура

@ul

- Веб процесс
  + User/admin/API интерфейсы
  + Работа с базой данных
- Утилиты
  + Управление приложением
  + Локализация, миграции, инструментарий
- Фоновые процессы
  + Отложенные задачи
  + Периодические задачи

@ulend

---

### Django. Создание проекта

TODO: Консольная утилита и/или cookiecutter

---

### Django. Консольная утилита

TODO: Опции консольной утилиты и как их использовать

---

### Django. Структура приложения

TODO: Различные варианты структур

---

### Django. База данных, модели, миграции

Что такое ORM и чем он может быть полезен.

---

## Deployment

Веб-приложение необходимо и желательно запустить на мастер-сервере

@ul

- WSGI, Gunicorn
- Сервер nginx, reverse proxy
- Supervisor, systemd

@ulend

---

### Web Server Gateway Interface

![WSGI Schema](img/5-wsgi.png)

Note:

- Описывает взаимодействие между веб-сервером и приложением на Python
- немного про CGI, fastCGI и прочее
- WSGI "импортирует" веб приложение

---

### Преимущества

@ul

- Гибкость: можем менять компоненты стэка
- Масштабируемость: компенсирует недостатки фреймворка
- Простота: явное разделение на компоненты системы
- Позволяет задействовать разнообразные middleware
- Хорошо вписывается в микросервисную архитектуру

@ulend

---

### Gunicorn

*Green Unicorn*. Pre-fork модель со множеством worker'ов

> pipenv install gunicorn

> gunicorn --workers 4 project:app

> gunicorn --pid /path/to/pid --bind unix:/path/to/socket app.wsgi

Note:

- также можно задать нужные параметры отдельным конфигурационным файлом
- зачем нам может понадобиться process id и сокет
- вазимодействие между приложениями

---

### Nginx

@ul

- Веб сервер для статического контента
- Прокси-сервер для динамических сайтов

@ulend

---?code=src/deploy/nginx.conf&lang=conf&color=white&title=Nginx server block
@[1-9](Обратный прокси для веб приложения)
@[2-3](Конфигурация домена)
@[5-8](Конфигурация прокси на порт 8000)
@[18](Тоже самое, но через сокет)
@[21-23](Доступ к статическим файлам вроде картинок)

---

<!-- ### uWSGI

- Существенно более богатый набор функциональности
- Несколько более сложная конфигурация

TODO: пример конфигурации

--- -->

### Systemd

@ul

- Системный менеджер Linux
- Позволяет запускать разнообразные службы и контроллировать их выполнение
- Оперирует отдельными конфигурационными Unit'ами
- Поддерживает различные типы Unit'ов

@ulend

Note:

Можно немного рассказать про типы unit'ов

---?code=src/deploy/gunicorn.service&lang=ini&color=white&title=Gunicorn service
@[1-3](Данный Unit зависит от сетевого сервиса)
@[5-12](Обозначим наш сервис)
@[8-12](Где и что будем запускать)
@[14-15](Запускаем данный сервис при обычной загрузке)

Note:

Multiline использован исключительно для примера

---

### Запуск сервиса



```bash
> sudo systemctl start gunicorn.service

> sudo systemctl status gunicorn.service

● gunicorn.service - gunicorn daemon
   Loaded: loaded (/etc/systemd/system/gunicorn.service; enabled; vendor preset: enabled)
   Active: active (running) since Sun 2018-07-08 17:02:43 MSK; 2 weeks 4 days ago
 Main PID: 21092 (gunicorn)
    Tasks: 11
   Memory: 393.0M
      CPU: 2h 39min 18.768s
   CGroup: /system.slice/gunicorn.service
           ├─21092 /path/.../venv/bin/python /path/.../gunicorn --workers 4 --bin
           ├─21092 /path/.../venv/bin/python /path/.../gunicorn --workers 4 --bin
           ...

> sudo systemctl enable gunicorn.service
```


---

## Заключение

@ul

- Vagrant
- Docker
- Примеры и демонстрация
- Микросервисы

@ulend

---

### Vagrant. Виртуальная среда разработки

@ul

- "песочница" под нужды проекта
- одинаковое окружение где бы то ни было
- простота развёртывания среды разработки

@ulend

---

### Микросервисы

![WSGI Schema](img/6-microservices.png)

---
### Docker

@ul

- виртуализация на уровне ОС
- меньшая требовательность к ресурсам
- возможность размножения контейнеров

@ulend

Note:

- в чём преимущества в сравнении с полноценной виртуальной машиной а-ля Vagrant
- добавить схему контейнеров и взаимодействия

---

### Docker. Контейнеры

![Docker Containers](img/7-docker-containers.png)

---

### Docker. Клиент & Сервер

Разделим клиент и сервер, поместив каждый из них в отдельный контейнер

@ul

- сервер работает с информацией и предоставляет API
- клиент отвечает за представление информации конечному пользователю

@ulend

<!-- ### Docker. Flask API -->

---?code=src/docker/api/app.py&lang=py&color=white&title=Flask API
@[2](Инструменты для создания API)
@[7-14](Эти данные мы потенциально могли бы получить из БД на другом контейнере)
@[15](Добавим как корневой маршрут)
@[18](Запустим на 80-м порту с локальным мета-адресом)

---?code=src/docker/api/Dockerfile&color=white&title=Dockerfile
@[1](Готовый образ с Python)
@[3-4](Рабочая директория приложения)
@[6-7](Установим зависимости через Pipenv)

Note:

Можно упомянуть CMD прочие интересные инструкции docker'а

<!-- ### Docker. Flask client -->

---?code=src/docker/client/app.py&lang=py&color=white&title=Bottle client
@[1-2](Импортируем фреймворк и утилиту для работы с API)
@[4-5](Корневой маршрут для отображения данных)
@[7-9](Получаем данные из другого контейнера)
@[10](Выводим их в шаблон)
@[12](Запустим приложение на другом порту)

<!-- ### Docker. Flask client. Template -->
---?code=src/docker/client/poets.tpl&lang=html&color=white&title=Bottle client template
@[13-15](Bottle использует SimpleTemplateEngine)

<!-- ### Docker. Compose -->

---?code=src/docker/docker-compose.yml&lang=yaml&color=white&title=Docker compose file
@[3-4,12](Обозначим наши сервисы-контейнеры)
@[5](Директория в которой находится Dockerfile)
@[6](Команда запуска нашего приложения)
@[8-9](Свяжем локальный путь с каталогом в самом контейнере)
@[10-11](Снаружи 80-й порт будет доступен как 5000-й)
@[19-29](Клиенту необходим API для работы)

Note:

- два типа volume, для чего может быть полезно
- автообновление приложений при изменении кода

---

### Docker. Запуск

> docker-compose build

> docker-compose up --detatch

> docker-compose ps

```bash
Name            Command      State           Ports         
----------------------------------------------------------------
docker_api_1      python app.py   Up      0.0.0.0:5000->80/tcp  
docker_client_1   python app.py   Up      0.0.0.0:5001->8080/tcp
```

---

### Docker. Продвинутый пример

TODO: nginx - django api - postgres - SPA cllient?

---

## Практика

---

### Задача №1.

Http-прокси сервер, запускаемый локально и отображающий
содержимое заданного сайта, с одной лишь только разницей: после каждого
слова из 10 букв должен стоять значок trademark, он же ™.

---

**Hard mode**:

- приложение должно запускаться как консольная утилита с параметрами
(к примеру: целевой сайт, порт прокси и т.п.)
- существующие ссылки должны работать в рамках прокси (с тем же эффектом)

---

### Задача №1. Инструментарий

- Git
- Virtualenv/Pipenv
- Bottle/Flask
- Requests
- BeautifulSoup
- Click

---

### Задача №2.

Приложение, позволяющее отправить через веб-форму некоторый текст.
 После успешного сабмита выдающее на основе этого текста набор комбинаций,
  сформированных через марковские цепи.

Пример: https://twitter.com/mashomatic

---

**Hard mode**:

- исходные данные и результирующие комбинации должны храниться в
базе данных и быть доступны для просмотра через некую историю сабмитов
- все когда либо отправленные тексты также используются при генерации новых
сообщений

---

### Задача №2. Инструментарий

- Git
- Virtualenv/Pipenv
- Flask/Django
- Markovify
- Sqlite

Note:

Более подробно задачи будут описаны непосредственно в репозитории

---

## Ссылки

Данная презентация
https://gitpitch.com/xifax/lectures-python-web/master

Репозиторий презентации
https://github.com/xifax/lectures-python-web

Репозиторий содержит примеры кода, картинки, тексты и "заметки на полях".
